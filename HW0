CHAPTER 1

1. 
#include <unistd.h>
int main() {
  write(1, "Hi! My name is Aarya", 20);
  return 0;
}

2. 
void write_triangle(int n) {
  int count;
  for (count = 0; count < n; count++) {
    int count1;
    for (count1 = 0; count1 < count; count1++) {
      write(1, "*", 1);
    }  
    write(2, "\n", 1);
  }
}

3.

#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
int main() {
  mode_t mode = S_IRUSR | S_IWUSR
  int fildes = open("hello_world.txt" , O_CREAT | O_TRUNC | O_RDWR, mode)
  write(fildes, "Hi! My name is Aarya", 20);
  close(fildes);
}

4. 

int main(){
	mode_t mode = S_IRUSR | S_IWUSR;
	int fildes = open("hello_world.txt", O_CREAT | O_TRUNC | O_RDWR, mode);
	dprintf(3, "Hi! My name is Aarya");
	close(fildes);
}

5. 
write() writes into the file itself, while printf() only writes to the console and does not write into the file. Also, printf()
lets you change how the output is seen, while write() does not.


CHAPTER 2

1. There at at least 8 bits in one byte
2. char is one byte
3. int: 4, double: 8, float: 4, long: 4, long long: 8
4. 0x7fbd9d48
5. data[3] is the same as data+3
6. Because the string "hello" is a constant and can only be read, not written
7. 12
8. 5
9. sizeof("hi")
10. sizeof(4)

CHAPTER 3
1. One way is to iterate through and the other way is to use argc to get the length
2. argv[0] represents the execution name of the program ex. ./program
3. They are stored on the stack
4. sizeof(ptr) is 5 because it is the number of bytes to actually hold the character pointer
    and sizeof(array) is 6 because it is the total size that is required to hold the array
5. the function the variable is in manages the lifetime of automatic variables

CHAPTER 4



CHAPTER 5
1. putchar(), puts()
2. The problem with gets() is that there is no way to tell it not to accept input that is too long for it, it can skew the output
3.
   


